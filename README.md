<div align="center">

# 🧮 Вычислительные методы

![Python](https://img.shields.io/badge/Python-3.x-3776AB?style=for-the-badge&logo=python&logoColor=white)
![Jupyter](https://img.shields.io/badge/Jupyter-Notebook-F37626?style=for-the-badge&logo=jupyter&logoColor=white)
![NumPy](https://img.shields.io/badge/NumPy-013243?style=for-the-badge&logo=numpy&logoColor=white)
![Matplotlib](https://img.shields.io/badge/Matplotlib-11557C?style=for-the-badge&logo=plotly&logoColor=white)

**Лабораторные работы по курсу «Вычислительные методы»**

**ИМИ СВФУ**

---

</div>

## 📂 Структура проекта

```
Computational-methods/
├── 📓 task_1.ipynb      # Лаб. 1 — Вычислительная погрешность
├── 📓 task_2.ipynb      # Лаб. 2 — Неустранимая погрешность
├── 📓 task_2.1.ipynb    # Лаб. 2 (расш.) — Прямое vs обратное суммирование
├── 📓 task_3.ipynb      # Лаб. 3 — Решение СЛАУ (LU-разложение)
└── 📘 README.md
```

---

## 🔬 Лабораторные работы

### 🟢 Лаб. 1 — Вычислительная погрешность

> 📓 [`task_1.ipynb`](task_1.ipynb)

Вычисление суммы $S = \sum_{n=1}^{10^6} \frac{\pi}{n^2}$ двумя способами:

| Метод | Направление | Описание |
|:-----:|:-----------:|----------|
| ➡️ Прямое | $1 \to N$ | Сумма от малых индексов к большим |
| ⬅️ Обратное | $N \to 1$ | Сумма от больших индексов к малым |

📊 **Результат:** разница $\approx 1.66 \times 10^{-13}$, относительная погрешность $\approx 3.21 \times 10^{-14}$

<details>
<summary>💡 Почему обратное суммирование точнее?</summary>

<br>

При прямом суммировании накопленная сумма быстро растёт, и мелкие слагаемые в хвосте **поглощаются** мантиссой `float64`. При обратном — мелкие числа успевают сложиться, пока масштаб суммы ещё мал.

```
1e16 + 1 = 1e16   ← единица пропала (мантисса забита)
```

</details>

---

### 🟡 Лаб. 2 — Неустранимая погрешность

> 📓 [`task_2.ipynb`](task_2.ipynb) · [`task_2.1.ipynb`](task_2.1.ipynb)

Исследование влияния точности входных данных на результат. Сумма вычисляется с приближёнными значениями $\pi$:

```
🎯 3 → 3.14 → 3.1415 → 3.141592 → ... → 3.14159265358979
```

| Файл | Содержание |
|:----:|-----------|
| 📓 `task_2.ipynb` | Таблица + график $\delta(S)$ от точности $\pi$ |
| 📓 `task_2.1.ipynb` | Сравнение прямого и обратного суммирования для каждого варианта $\pi$, графики разностей |

📈 Графики строятся в логарифмической шкале — наглядно видна линейная зависимость погрешности от числа верных знаков $\pi$.

---

### 🔴 Лаб. 3 — Решение СЛАУ методом LU-разложения

> 📓 [`task_3.ipynb`](task_3.ipynb)

Решение системы $Ax = b$ методом LU-разложения на чистом Python (циклы + условные операторы).

**⚙️ Алгоритм (3 этапа):**

```
┌─────────────────────────────────────────────────┐
│  Этап 1 │  A = LU          (LU-разложение)      │
│  Этап 2 │  Ly = b  → y     (прямая подстановка) │
│  Этап 3 │  Ux = y  → x     (обратная подстановка)│
└─────────────────────────────────────────────────┘
```

**🔑 Ключевая формула:**

$$l_{jk} = \frac{a_{jk}}{a_{kk}}, \quad k < j \leq n$$

**✅ Проверки:**
- $L \cdot U = A$ — точное совпадение
- Невязка $\|Ax - b\|_\infty = 0$
- Сверка с `numpy.linalg.solve`

---

## 🚀 Запуск

```bash
# клонировать репозиторий
git clone <url>
cd Computational-methods

# запустить Jupyter
jupyter notebook
```

Открыть нужный `.ipynb` → **Cell → Run All** ▶️

---

## 🛠 Стек технологий

<div align="center">

| Технология | Назначение |
|:----------:|-----------|
| 🐍 Python 3 | Основной язык |
| 📓 Jupyter Notebook | Среда выполнения |
| 📐 `math` | Математические константы и функции |
| 📊 `matplotlib` | Построение графиков |
| 🔢 `numpy` | Проверка решений (лаб. 3) |

</div>

---

<div align="center">

**ИМИ СВФУ** · Вычислительные методы · 2025

</div>
